
        Implementare:

In cadrul rezolvarii temei am ales sa folosesc o lista circulara
dublu inlantuita  pentru implementarea load_balancer-ului,
deoarce accesare vecinilor unui nod se poate efectua intr-un 
mod eficient.In reprezentare, fiecare nod al hash ring-ului 
contine pe langa cei doi pointeri next si prev, un  pointer la
o structura server care contine un hashtable, un id si un hash 
al unei replici.Pentru partea de server am folosit un hashtable
care contine un array de liste simplu inlantuite.


Server:

Pentru aceasta parte am folosit scheletul si functiile implementate
in cadrul laboratorului de liste simplu inlantuite si hashtable.

Functii:
init_server_memory-> In cadrul acestei functii am creat si am
initializat server=ul, respectiv hashtable-ul acestuia

serve_store-> In cadrul acestei functii am apelat functia care
adauga o noua pereche cheie-valoare in hashtable-ul server-ului

server_remove-> In cadrul acestei functii am apelat functia
de stergere a unei valori din hashtable-ul serverului dorit

server_retrive-> In cadrul acestei functii am extras un obiect
pe baza unei chei transmise ca parametru din hashtable-ul server-ului

free_server_memory-> In cadrul acestei functii am eliberat mai intai 
memoria unui hastable, apoi am eliberat memoria alocata server-ului 
si am redirectat pointerul catre NULL


Load Balancer:

Pentru aceasta parte am folosit scheletul si functiile implementate
in cadrul laboratorului de lista circulara dublu inlantuita .

Functii:
init_load_balancer-> In cadrul acestei functii am alocat load
balancer-ul, am creat si intializat hash_ring-ul sub forma
de lista circulara dublu inlantuita.

load_store-> In cadrul acestei functii am parcurs lista, si
daca am gasit un server valid adaug un obiect cu cheia si valoarea
transmise ca parametru in hashtable-ul server-ului dorit

load_retrive-> Similar functiei de mai sus am parcurs lista,
iar daca am gasit un server valid am extras valoarea obiectului
cu cheia dorita din cadrul hashtable-ului

load_add_server-> In cadrul acestei functii am creat si initializat
un server, iar pe baza a trei replici diferite, folosind hashing
l-am adaugat de trei ori in cadrul hash_ring-ului.

load_remove_server-> In cadrul acestei functii am apelat de trei
ori functia care sterge o replica a unui server din hash_ring

free_load_balancer-> In cadrul acestei functii am parcurs lista
si am sters replicile, apoi am apelat functia specifica listei
care elibereaza memoria fiecarui nod.In final am eliberat load
balancer-ul si am redirectat pointer-ul care NULL

add_server-> In cadrul acestei functii am verificat daca lista
este goala si in caz afirmativ am adaugat replica unui server
la inceputul listei. Altfel, am parcurs lista si am numarat pe
cate pozitii hash-ul serverului este mai mic decat cel al carui
server dorim sa il adaugam. Apoi am adaugat nodul in lista
(dll_add_nth_node intoarce un pointer la pozitia pe care am 
adaugat o pentru a nu parcurge lista de mai multe ori),
si apoi am cautat si distribuit obiecte de la serverele vecine
catre noul server adaugat.

remove_server-> Similar functiei de mai sus, am parcurs lista
pe a determina pozitia de pe care trebuie sters un server. Apoi
am extras nodul dorit din hash_ring si am redistribuit obiectele
acestuia catre server-le vecine.In final am sters hastable-ul 
server-ului o singura data(ultima replica) si am eliminat replica
din cadrul hash-ring-ului folosind functia dll_remove_nth_node si
pozitia determinata initial.

Pentru erorile legate de alocarea memoriei am folosit macro-ul
DIE preluat din headerul utils.h
